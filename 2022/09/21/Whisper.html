<!DOCTYPE html>
<!-- _layouts/paper-note.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    
    <!-- Website verification -->
    <meta name="google-site-verification" content="">
<!-- Avoid warning on Google Chrome
        Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.
        see https://stackoverflow.com/a/75119417
    -->
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Whisper: Web-Scale Supervised Pretraining for Speech Recognition | Molin  Zhang</title>
    <meta name="author" content="Molin  Zhang">
    <meta name="description" content="Robust Speech Recognition via Large-Scale Weak Supervision">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="/assets/img/favicon.ico">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://molinzhang.github.io/2022/09/21/Whisper.html">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
    <style type="text/css">
      .highlight pre:not(.language-text) { background-color: #272822; color: #f8f8f2;}
      .highlight .hll { background-color: #272822; }
      .highlight .comment { color: #75715e } /* Comment c */
      .highlight .err { color: #960050; background-color: #1e0010 } /* Error */
      .highlight .keyword { color: #66d9ef } /* Keyword k*/
      .highlight .l { color: #ae81ff } /* Literal */
      .highlight .n { color: #f8f8f2 } /* Name */
      .highlight .operator { color: #f92672 } /* Operator o*/
      .highlight .punctuation { color: #f8f8f2 } /* Punctuation p*/
      .highlight .cm { color: #75715e } /* Comment.Multiline */
      .highlight .cp { color: #75715e } /* Comment.Preproc */
      .highlight .c1 { color: #75715e } /* Comment.Single */
      .highlight .cs { color: #75715e } /* Comment.Special */
      .highlight .ge { font-style: italic } /* Generic.Emph */
      .highlight .gs { font-weight: bold } /* Generic.Strong */
      .highlight .kc { color: #66d9ef } /* Keyword.Constant */
      .highlight .kd { color: #66d9ef } /* Keyword.Declaration */
      .highlight .kn { color: #f92672 } /* Keyword.Namespace */
      .highlight .kp { color: #66d9ef } /* Keyword.Pseudo */
      .highlight .kr { color: #66d9ef } /* Keyword.Reserved */
      .highlight .kt { color: #66d9ef } /* Keyword.Type */
      .highlight .ld { color: #e6db74 } /* Literal.Date */
      .highlight .number { color: #ae81ff } /* Literal.Number m*/
      .highlight .string { color: #e6db74 } /* Literal.String s*/
      .highlight .na { color: #a6e22e } /* Name.Attribute */
      .highlight .builtin { color: #f8f8f2 } /* Name.Builtin nb*/
      .highlight .class-name { color: #a6e22e } /* Name.Class nc*/
      .highlight .no { color: #66d9ef } /* Name.Constant */
      .highlight .decorator { color: #a6e22e } /* Name.Decorator nd*/
      .highlight .ni { color: #f8f8f2 } /* Name.Entity */
      .highlight .ne { color: #a6e22e } /* Name.Exception */
      .highlight .function { color: #a6e22e } /* Name.Function nf*/
      .highlight .nl { color: #f8f8f2 } /* Name.Label */
      .highlight .nn { color: #f8f8f2 } /* Name.Namespace */
      .highlight .nx { color: #a6e22e } /* Name.Other */
      .highlight .py { color: #f8f8f2 } /* Name.Property */
      .highlight .nt { color: #f92672 } /* Name.Tag */
      .highlight .nv { color: #f8f8f2 } /* Name.Variable */
      .highlight .ow { color: #f92672 } /* Operator.Word */
      .highlight .w { color: #f8f8f2 } /* Text.Whitespace */
      .highlight .mf { color: #ae81ff } /* Literal.Number.Float */
      .highlight .mh { color: #ae81ff } /* Literal.Number.Hex */
      .highlight .mi { color: #ae81ff } /* Literal.Number.Integer */
      .highlight .mo { color: #ae81ff } /* Literal.Number.Oct */
      .highlight .sb { color: #e6db74 } /* Literal.String.Backtick */
      .highlight .sc { color: #e6db74 } /* Literal.String.Char */
      .highlight .sd { color: #e6db74 } /* Literal.String.Doc */
      .highlight .s2 { color: #e6db74 } /* Literal.String.Double */
      .highlight .se { color: #ae81ff } /* Literal.String.Escape */
      .highlight .sh { color: #e6db74 } /* Literal.String.Heredoc */
      .highlight .si { color: #e6db74 } /* Literal.String.Interpol */
      .highlight .sx { color: #e6db74 } /* Literal.String.Other */
      .highlight .sr { color: #e6db74 } /* Literal.String.Regex */
      .highlight .s1 { color: #e6db74 } /* Literal.String.Single */
      .highlight .ss { color: #e6db74 } /* Literal.String.Symbol */
      .highlight .bp { color: #f8f8f2 } /* Name.Builtin.Pseudo */
      .highlight .vc { color: #f8f8f2 } /* Name.Variable.Class */
      .highlight .vg { color: #f8f8f2 } /* Name.Variable.Global */
      .highlight .vi { color: #f8f8f2 } /* Name.Variable.Instance */
      .highlight .il { color: #ae81ff } /* Literal.Number.Integer.Long */
      .highlight .gh { } /* Generic Heading & Diff Header */
      .highlight .gu { color: #75715e; } /* Generic.Subheading & Diff Unified/Comment? */
      .highlight .gd { color: #f92672; } /* Generic.Deleted & Diff Deleted */
      .highlight .gi { color: #a6e22e; } /* Generic.Inserted & Diff Inserted */
    </style>
    <script> configObj = { "buttonD": "M8 18.568L10.8 21.333 16 16.198 21.2 21.333 24 18.568 16 10.667z", "buttonT": "translate(-1148 -172) translate(832 140) translate(32 32) translate(284)", "shadowSize": "none", "roundnessSize": "999px", "buttonDToBottom": "64px", "buttonDToRight": "32px", "selectedBackgroundColor": "#c2c0bf", "selectedIconColor": "#a31f34", "buttonWidth": "40px", "buttonHeight": "40px", "svgWidth": "32px", "svgHeight": "32px" }; function createButton(obj, pageSimulator) { const body = document.querySelector("body"); backToTopButton = document.createElement("span"); backToTopButton.classList.add("softr-back-to-top-button"); backToTopButton.id = "softr-back-to-top-button"; pageSimulator ? pageSimulator.appendChild(backToTopButton) : body.appendChild(backToTopButton); backToTopButton.style.width = obj.buttonWidth; backToTopButton.style.height = obj.buttonHeight; backToTopButton.style.marginRight = obj.buttonDToRight; backToTopButton.style.marginBottom = obj.buttonDToBottom; backToTopButton.style.borderRadius = obj.roundnessSize; backToTopButton.style.boxShadow = obj.shadowSize; backToTopButton.style.color = obj.selectedBackgroundColor; backToTopButton.style.backgroundColor = obj.selectedBackgroundColor; pageSimulator ? backToTopButton.style.position = "absolute" : backToTopButton.style.position = "fixed"; backToTopButton.style.outline = "none"; backToTopButton.style.bottom = "0px"; backToTopButton.style.right = "0px"; backToTopButton.style.cursor = "pointer"; backToTopButton.style.textAlign = "center"; backToTopButton.style.border = "solid 2px currentColor"; backToTopButton.innerHTML = '<svg class="back-to-top-button-svg" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" > <g fill="none" fill-rule="evenodd"> <path d="M0 0H32V32H0z" transform="translate(-1028 -172) translate(832 140) translate(32 32) translate(164) matrix(1 0 0 -1 0 32)" /> <path class="back-to-top-button-img" fill-rule="nonzero" d="M11.384 13.333h9.232c.638 0 .958.68.505 1.079l-4.613 4.07c-.28.246-.736.246-1.016 0l-4.613-4.07c-.453-.399-.133-1.079.505-1.079z" transform="translate(-1028 -172) translate(832 140) translate(32 32) translate(164) matrix(1 0 0 -1 0 32)" /> </g> </svg>'; backToTopButtonSvg = document.querySelector(".back-to-top-button-svg"); backToTopButtonSvg.style.verticalAlign = "middle"; backToTopButtonSvg.style.margin = "auto"; backToTopButtonSvg.style.justifyContent = "center"; backToTopButtonSvg.style.width = obj.svgWidth; backToTopButtonSvg.style.height = obj.svgHeight; backToTopButton.appendChild(backToTopButtonSvg); backToTopButtonImg = document.querySelector(".back-to-top-button-img"); backToTopButtonImg.style.fill = obj.selectedIconColor; backToTopButtonSvg.appendChild(backToTopButtonImg); backToTopButtonImg.setAttribute("d", obj.buttonD); backToTopButtonImg.setAttribute("transform", obj.buttonT); if (!pageSimulator) { backToTopButton.style.display = "none"; window.onscroll = function () { if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) { backToTopButton.style.display = "block"; } else { backToTopButton.style.display = "none"; } }; backToTopButton.onclick = function () { document.body.scrollTop = 0; document.documentElement.scrollTop = 0; }; } }; document.addEventListener("DOMContentLoaded", function () { createButton(configObj, null); });</script>
  </head>
  
  <body class="fixed-top-nav">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Molin </span>Zhang</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/">teaching</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/services/">services</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>Whisper: Web-Scale Supervised Pretraining for Speech Recognition</h1>
        <p>Robust Speech Recognition via Large-Scale Weak Supervision</p>
      </d-title>

      <d-byline>
          <div class="byline grid">
            <div>
              <h3>Published</h3>
                <p>September 21, 2022</p> 
            </div>
            
            <div>
              <h3>Paper</h3>
                <p><a href="https://arxiv.org/pdf/2212.04356.pdf" rel="external nofollow noopener" target="_blank">PDF</a></p> 
            </div>
            
            
            <div>
              <h3>Code</h3>
                <p><a href="https://github.com/openai/whisper" rel="external nofollow noopener" target="_blank">Github</a></p> 
            </div>
            
          </div>
      </d-byline>

      <d-article>
        <d-contents>
          <nav class="l-text figcaption">
          <h3>Contents</h3>
            <div><a href="#takeaways">Takeaways</a></div>
            <div><a href="#introduction">Introduction</a></div>
            <div><a href="#methods">Methods</a></div>
            <ul>
              <li><a href="#dataset">Dataset</a></li>
              <li><a href="#model">Model</a></li>
              <li><a href="#multitask-format">Multitask Format</a></li>
              
            </ul>
<div><a href="#experiments">Experiments</a></div>
            <ul>
              <li><a href="#evaluation">Evaluation</a></li>
              <li><a href="#english-speech-recognition">English Speech Recognition</a></li>
              <li><a href="#multi-lingual-speech-recognition">Multi-lingual Speech Recognition</a></li>
              <li><a href="#translation">Translation</a></li>
              <li><a href="#language-identification">Language Identification</a></li>
              <li><a href="#robustness-to-additive-noise">Robustness to Additive Noise</a></li>
              <li><a href="#long-form-transcription">Long-form Transcription</a></li>
              <li><a href="#comparison-with-human-performance">Comparison with Human Performance</a></li>
              <li><a href="#ablations">Ablations</a></li>
              
            </ul>
<div><a href="#limitations">Limitations</a></div>
            
          </nav>
        </d-contents>

        <h2 id="takeaways">Takeaways</h2>

<ul>
  <li>Whisper is a <strong>multi-lingual</strong> and <strong>multi-task</strong> speech processing pipeline based on the encoder-decoder Transformer.</li>
  <li>Whisper is trained on 680,000 hours of labeled audio data from the Internet (<strong>weakly supervised</strong>) to predict the transcripts of the audio.</li>
  <li>Whisper generalizes well to standard benchmarks and is often competitive with prior fully supervised results but in a <strong>zero-shot transfer</strong> setting.</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Previous work on <strong>unsupervised</strong> pre-training</p>

<ul>
  <li>e.g., wav2vec 2.0 and BigSSL.</li>
  <li>Learn directly from <em>raw audio</em> without labels.</li>
  <li>Scaled up to 1,000,000 hours of training data.</li>
  <li>Learn high-quality representations of speech.</li>
  <li>Lack of an equivalently performant decoder mapping those representations to usable outputs, necessitating a finetuning stage in order to actually perform a task.</li>
  <li>Risk of fine-tuning: overfit to spurious patterns and don’t generalize to other datasets.</li>
</ul>

<p>Previous work on <strong>supervised</strong> pre-training</p>

<ul>
  <li>Pre-training across many datasets/domains in a supervised fashion.</li>
  <li>Higher robustness and better generalizability.</li>
  <li>Only a moderate amount of this data is easily available (thousands of hours).</li>
</ul>

<p>Dataset for <strong>weakly supervised</strong> learning</p>

<ul>
  <li>Trade-off between quality and quantity: create larger datasets for speech recognition by relaxing the requirement of gold-standard human-validated transcripts</li>
  <li>These new datasets are only a few times larger than the sum of existing high-quality datasets and still much smaller than prior unsupervised work.</li>
</ul>

<p>This work</p>

<ul>
  <li>Study the capabilities of speech processing systems trained simply to <strong>predict large amounts of transcripts of audio</strong> on the Internet.</li>
  <li>Scale weakly supervised speech recognition the next order of magnitude to 680,000 hours of labeled audio data.</li>
  <li>Remove the need for any dataset-specific fine-tuning to achieve high quality.</li>
  <li>Broaden the scope of weakly supervised pre-training beyond English-only speech recognition to be both <em>multilingual</em> and <em>multitask</em>.</li>
  <li>The resulting models (Whisper) generalize well to standard benchmarks and are often competitive with prior fully supervised results but in a <strong>zero-shot transfer</strong> setting.</li>
</ul>

<h2 id="methods">Methods</h2>

<div class="l-page" style="text-align:center;">
  <img src="https://raw.githubusercontent.com/openai/whisper/main/approach.png" width="100%" style="margin-bottom: 12px; background-color: white;">
  <p>Overview of Whisper.</p>
</div>

<h3 id="dataset">Dataset</h3>

<p>A minimalist approach to data pre-processing:</p>

<ul>
  <li>Train models to predict the <strong>raw text of transcripts</strong>.</li>
  <li>No significant standardization</li>
  <li>Rely on the expressiveness of seq-to-seq models to learn to map between utterances and their transcribed form.</li>
  <li>Simplify the pipeline since it removes the need for a separate inverse text normalization step.</li>
</ul>

<p>Construct a very diverse dataset from the audio that is paired with transcripts on the Internet. While diversity in audio quality can help train a model to be robust, diversity in transcript quality is not similarly beneficial.</p>

<p>Filtering for transcript:</p>

<ul>
  <li>Remove machine-generated transcripts from the training dataset.</li>
  <li>Remove the (audio, transcript) pair if the spoken language doesn’t match the language of the transcript. Exception: if the transcript language is English, add these pairs to the dataset as <code class="language-plaintext highlighter-rouge">X -&gt; en</code> speech translation training examples instead.</li>
  <li>Fuzzy de-duping of transcript texts to reduce the amount of duplication and automatically generated content in the training dataset.</li>
  <li>Break audio files into 30-second segments paired with the subset of the transcript that occurs within that time segment.</li>
  <li>Train on all audio, including segments where there is no speech, and use these segments as training data for voice activity detection.</li>
  <li>After training an initial model, aggregated information about its error rate on training data sources and performed a manual inspection of these data sources sorting by a combination of both high error rate and data source size in order to identify and remove low-quality ones efficiently.</li>
  <li>To avoid contamination, perform de-duplication at a transcript level between the training dataset and the evaluation datasets.</li>
</ul>

<h3 id="model">Model</h3>

<h4 id="input-audio">Input Audio</h4>

<ol>
  <li>All audio is re-sampled to 16,000 Hz.</li>
  <li>An 80-channel log magnitude Mel spectrogram representation is computed on 25-millisecond windows with a stride of 10 milliseconds.</li>
  <li>Globally scale the input to be between -1 and 1 with approximately zero mean across the pre-training dataset.</li>
</ol>

<h4 id="network">Network</h4>

<ul>
  <li>Use off-the-shelf architecture: encoder-decoder Transformer<d-cite key="Transformer"></d-cite>
</li>
  <li>The encoder processes this input representation with a small stem consisting of two convolution layers with a filter width of 3 and the GELU activation function, where the second convolution layer has a stride of two.</li>
  <li>Sinusoidal position embeddings are then added to the output of the stem after which the encoder Transformer blocks are applied</li>
  <li>Uses pre-activation residual blocks</li>
  <li>A final layer normalization is applied to the encoder output</li>
  <li>The decoder uses learned position embeddings and tied input-output token representations</li>
  <li>Number of parameters for Whisper-Large: 1550M</li>
</ul>

<h4 id="vocabulary">Vocabulary</h4>

<ul>
  <li>Use the same byte-level BPE text tokenizer used in GPT2 for the English only models.</li>
  <li>Refit the vocabulary (but keep the same size) for the multilingual models to avoid excessive fragmentation on other languages.</li>
</ul>

<h3 id="multitask-format">Multitask Format</h3>

<p>In addition to predicting which words were spoken in a given audio snippet, A fully featured speech recognition system can involve many additional components, e.g., voice activity detection, speaker diarization (i.e., the process of partitioning an input audio stream into homogeneous segments according to the speaker identity), and inverse text normalization.</p>

<p>To reduce this complexity, this work uses a single model to perform the entire speech processing pipeline and uses a simple format to specify all tasks and conditioning information as a sequence of input tokens to the decoder.</p>

<p>Since the decoder is an audio-conditional language model, the authors also train it to condition on the history of the text of the transcript in the hope that it will learn to use longer-range text context to resolve ambiguous audio. Specifically, with some probability, the transcript text preceding the current audio segment is added to the decoder’s context.</p>

<ol>
  <li>Indicate the beginning of the prediction with a <code class="language-plaintext highlighter-rouge">&lt;|startoftranscript|&gt;</code> token.</li>
  <li>First, predict the language being spoken which is represented by a unique token for each language in our training set (99 total). If there is no speech in an audio segment, the model is trained to predict a <code class="language-plaintext highlighter-rouge">&lt;|nospeech|&gt;</code> token.</li>
  <li>The next token specifies the task (either transcription or translation) with an <code class="language-plaintext highlighter-rouge">&lt;|transcribe|&gt;</code> or <code class="language-plaintext highlighter-rouge">&lt;|translate|&gt;</code> token.</li>
  <li>After this, specify whether to predict timestamps or not by including a <code class="language-plaintext highlighter-rouge">&lt;|notimestamps|&gt;</code> token for that case.</li>
  <li>At this point, the task and desired format are fully specified, and the output begins.</li>
  <li>Timestamp prediction:
    <ol>
      <li>Predict time relative to the current audio segment, quantizing all times to the nearest 20 milliseconds which matches the native time resolution of Whisper models, and add additional tokens to our vocabulary for each of these.</li>
      <li>Interleave timestamp prediction with the caption tokens: the start time token is predicted before each caption’s text, and the end time token is predicted after.</li>
      <li>When a final transcript segment is only partially included in the current 30-second audio chunk, we predict only its start time token for the segment when in timestamp mode, to indicate that the subsequent decoding should be performed on an audio window aligned with that time, otherwise we truncate the audio to not include the segment.</li>
    </ol>
  </li>
  <li>Lastly, add a <code class="language-plaintext highlighter-rouge">&lt;|endoftranscript|&gt;</code> token.</li>
  <li>Only mask out the training loss over the previous context text, and train the model to predict all other tokens.</li>
</ol>

<h2 id="experiments">Experiments</h2>

<h3 id="evaluation">Evaluation</h3>

<p>The goal of Whisper is to develop a single robust speech processing system that works reliably without the need for dataset-specific fine-tuning to achieve high-quality results on specific distributions.</p>

<p>Evaluate Whisper in a <strong>zero-shot setting</strong> without using any of the training data for each of the datasets to measure broad generalization.</p>

<p>Metrics: word error rate (WER)</p>

<ul>
  <li>Sensitive to minor formatting differences.</li>
  <li>Apply extensive standardization of text before the WER calculation to minimize penalization of non-semantic differences.</li>
</ul>

<h3 id="english-speech-recognition">English Speech Recognition</h3>

<p>For the previous SOTA supervised methods, there is a gap between reportedly superhuman performance in-distribution and subhuman performance out-of-distribution.</p>

<p>This might be due to conflating different capabilities being measured by human and machine performance on a test set.</p>

<ul>
  <li>Humans are often asked to perform a task given little to no supervision on the specific data distribution. Thus human performance is a measure of out-of-distribution generalization.</li>
  <li>But machine learning models are usually evaluated after training on a large amount of supervision from the evaluation distribution, meaning that machine performance is instead a measure of in-distribution generalization.</li>
</ul>

<p>Results:</p>

<ul>
  <li>Although the best zero-shot Whisper model has a relatively unremarkable LibriSpeech clean-test WER of 2.5, which is roughly the performance of a modern supervised baseline or the mid-2019 SOTA,</li>
  <li>zero-shot Whisper models have very different robustness properties than supervised LibriSpeech models and outperform all benchmarked LibriSpeech models by large amounts on other datasets.</li>
  <li>Zero-shot Whisper models close the gap to human robustness: The best zero-shot Whisper models roughly match human accuracy and robustness.</li>
</ul>

<h3 id="multi-lingual-speech-recognition">Multi-lingual Speech Recognition</h3>

<h4 id="low-data-benchmarks">Low-data Benchmarks</h4>

<p>Whisper performs well on Multilingual LibriSpeech. However, On VoxPopuli, Whisper significantly underperforms prior work.</p>

<h4 id="relationship-between-size-of-dataset-and-performance">Relationship between Size of Dataset and Performance</h4>

<ul>
  <li>Studied the relationship between the amount of training data for a given language and the resulting downstream zero-shot performance for that language.</li>
  <li>Found a strong squared correlation coefficient of 0.83 between the log of the word error rate and the log of the amount of training data per language.</li>
  <li>Many of the largest outliers in terms of worse-than-expected performance according to this trend are languages that have unique scripts and are more distantly related to the Indo-European languages. These differences could be due to a lack of transfer due to linguistic distance, the byte-level BPE tokenizer being a poor match for these languages or variations in data quality.</li>
</ul>

<h3 id="translation">Translation</h3>

<p>Study the translation capabilities of Whisper by measuring the performance on the <code class="language-plaintext highlighter-rouge">X -&gt; en</code> translation.</p>

<p>Results:</p>

<ul>
  <li>Achieved a new SOTA of 29.1 BLEU zero-shot without using any of the CoVoST2 training data. These results may be attributed to the 68,000 hours of <code class="language-plaintext highlighter-rouge">X -&gt; en</code> translation data for these languages in our pre-training dataset which, although noisy, is vastly larger than the 861 hours of training data for <code class="language-plaintext highlighter-rouge">X -&gt; en</code> translation in CoVoST2.</li>
  <li>Since Whisper evaluation is zero-shot, it does particularly well on the lowest resource grouping of CoVoST2, improving over mSLAM by 6.7 BLEU. Conversely, the best Whisper model does not actually improve over Maestro and mSLAM on average for the highest resource languages.</li>
</ul>

<h3 id="language-identification">Language Identification</h3>

<p>The zero-shot performance of Whisper is not competitive with prior supervised work here and underperforms the supervised SOTA by 13.6%.</p>

<h3 id="robustness-to-additive-noise">Robustness to Additive Noise</h3>

<ul>
  <li>There are many models that outperform the zero-shot Whisper performance under low noise (40 dB SNR), which is unsurprising given those models are trained primarily on LibriSpeech,</li>
  <li>but all models quickly degrade as the noise becomes more intensive, performing worse than the Whisper model under additive pub noise of SNR below 10 dB.</li>
  <li>This showcases Whisper’s robustness to noise, especially under more natural distribution shifts like the pub noise.</li>
</ul>

<h3 id="long-form-transcription">Long-form Transcription</h3>

<ul>
  <li>Whisper models are trained on 30-second audio chunks and cannot consume longer audio inputs at once.</li>
  <li>The authors developed a strategy to perform buffered transcription of long audio by consecutively transcribing 30-second segments of audio and shifting the window according to the timestamps predicted by the model.</li>
  <li>It is crucial to have beam search and temperature scheduling based on the repetitiveness and the log probability of the model predictions in order to reliably transcribe long audio.</li>
</ul>

<p>Results: Whisper is competitive with state-of-the-art commercial and open-source ASR systems in long-form transcription.</p>

<h3 id="comparison-with-human-performance">Comparison with Human Performance</h3>

<p>These results indicate that Whisper’s English ASR performance is not perfect but very close to human-level accuracy.</p>

<h3 id="ablations">Ablations</h3>

<h4 id="model-scaling">Model Scaling</h4>

<p>Concerns with using a large but noisy dataset:</p>

<ul>
  <li>Although it may look promising to begin with, the performance of models trained on this kind of data may saturate at the inherent quality level of the dataset.</li>
  <li>As capacity and compute spent training on the dataset increases, models may learn to exploit the idiosyncrasies of the dataset, and their ability to generalize robustly to out-of-distribution data could even degrade.</li>
</ul>

<p>Study the zero-shot generalization of Whisper models as a function of the model size.</p>

<ul>
  <li>With the exception of English speech recognition, performance continues to increase with model size across multilingual speech recognition, speech translation, and language identification.</li>
  <li>The diminishing returns for English speech recognition could be due to saturation effects from approaching human-level performance.</li>
</ul>

<h4 id="dataset-scaling">Dataset Scaling</h4>

<p>To study how important is the raw dataset size to Whisper’s performance</p>

<p>Results:</p>

<ul>
  <li>All increases in the dataset size result in improved performance on all tasks</li>
  <li>The general trend across tasks of diminishing returns when moving from 54,000 hours to the full dataset size of 680,000 hours could suggest that
    <ul>
      <li>the current best Whisper models are under-trained relative to dataset size and performance could be further improved by a combination of longer training and larger models.</li>
      <li>we are nearing the end of performance improvements from dataset size scaling for speech recognition.</li>
      <li>Further analysis is needed to characterize “scaling laws” for speech recognition in order to decide between these explanations.</li>
    </ul>
  </li>
</ul>

<h4 id="multitask-and-multilingual-transfer">Multitask and Multilingual Transfer</h4>

<p>A potential concern with jointly training a single model on many tasks and languages is the possibility of negative transfer where interference between the learning of several tasks results in performance worse than would be achieved by training on only a single task or language.</p>

<p>Compare the performance of models trained on <em>just English</em> speech recognition with the standard multitask and multilingual training setup.</p>

<p>Results:</p>

<ul>
  <li>For small models trained with moderate amounts of compute, there is indeed negative transfer between tasks and languages: joint models underperform English-only models trained for the same amount of compute.</li>
  <li>Multitask and multi-lingual models scale better and for the largest experiments outperform their English-only counterparts demonstrating positive transfer from other tasks.</li>
</ul>

<h4 id="text-normalization">Text Normalization</h4>

<p>There is a risk of overfitted text normalization.</p>

<p>Compare the performance of Whisper using the proposed normalizer versus an independently developed one from another project.</p>

<p>Results:</p>

<ul>
  <li>On most datasets, the two normalizers perform similarly.</li>
  <li>On some datasets, the proposed normalizer reduces the WER of Whisper significantly more. The differences in reduction can be traced down to different formats used by the ground truth and how the two normalizers are penalizing them.</li>
</ul>

<h4 id="strategies-for-reliable-long-form-transcription">Strategies for Reliable Long-form Transcription</h4>

<p>Transcribing long-form audio using Whisper relies on accurate prediction of the timestamp tokens to determine the amount to shift the model’s 30-second audio context window by, and inaccurate transcription in one window may negatively impact transcription in the subsequent windows.</p>

<p>Strategies to avoid failure cases of long-form transcription:</p>

<ul>
  <li>
<strong>Beam search:</strong> Use beam search with 5 beams using the log probability as the score function, to reduce repetition looping which happens more frequently in greedy decoding.</li>
  <li>
<strong>Temperature fallback:</strong> The temperature starts with 0, i.e. always selecting the tokens with the highest probability, and increases by 0.2 up to 1.0 when either the average log probability over the generated tokens is lower than −1 or the generated text has a gzip compression rate higher than 2.4.</li>
  <li>
<strong>Previous text conditioning:</strong> Providing the transcribed text from the preceding window as previous-text conditioning when the applied temperature is below 0.5 further improves the performance.</li>
  <li>
<strong>Voice activity detection:</strong> The probability of the <code class="language-plaintext highlighter-rouge">&lt;|nospeech|&gt;</code> token alone is not sufficient to distinguish a segment with no speech, but combining the no-speech probability threshold of 0.6 and the average log-probability threshold of −1 makes the voice activity detection of Whisper more reliable.</li>
  <li>
<strong>Initial timestamp constraint:</strong> To avoid a failure mode where the model ignores the first few words in the input, the authors constrained the initial timestamp token to be between 0.0 and 1.0 second.</li>
</ul>

<h2 id="limitations">Limitations</h2>

<h3 id="improved-decoding-strategies">Improved Decoding Strategies</h3>

<p>Perception-related errors:</p>

<ul>
  <li>e.g., confusing similar-sounding words.</li>
  <li>Larger models have made steady and reliable progress on reducing perception-related errors.</li>
</ul>

<p>Non-perceptual errors:</p>

<ul>
  <li>e.g., getting stuck in repeat loops, not transcribing the first or last few words of an audio segment, or outputting a transcript entirely unrelated to the actual audio.</li>
  <li>More stubborn in nature.</li>
  <li>They are a combination of failure modes of seq2seq models, language models, and text-audio alignment.</li>
  <li>Potential solutions:
    <ul>
      <li>Fine-tuning on a high-quality supervised dataset</li>
      <li>Using reinforcement learning to more directly optimize for decoding performance.</li>
    </ul>
  </li>
</ul>

<h3 id="increase-training-data-for-lower-resource-languages">Increase Training Data For Lower-Resource Languages</h3>

<p>Whisper’s speech recognition performance is still quite poor on many languages.</p>

<p>The pre-training dataset is currently very English-heavy due to biases of the data collection pipeline.</p>

<p>A targeted effort at increasing the amount of data for these rarer languages could result in a large improvement to average speech recognition performance even with only a small increase in the overall training dataset size.</p>

<h3 id="studying-fine-tuning">Studying Fine-Tuning</h3>

<p>This work focused on the robustness properties of speech processing systems and as a result only studied the zero-shot transfer.</p>

<p>It is likely that results can be improved further by fine-tuning.</p>

<h3 id="studying-the-impact-of-language-models-on-robustness">Studying the Impact of Language Models on Robustness</h3>

<p>The authors suspect that Whisper’s robustness is partially due to its strong decoder, which is an audio-conditional LM.</p>

<p>It’s currently unclear to what degree the benefits of Whisper stem from training its encoder, decoder, or both.</p>

<p>Potential Experiments:</p>

<ul>
  <li>Train a decoder-less CTC model.</li>
  <li>Study how the performance of existing speech recognition encoders change when used together with a language model.</li>
</ul>

<h3 id="adding-auxiliary-training-objectives">Adding Auxiliary Training Objectives</h3>

<p>Whisper departs noticeably from the most recent SOTA speech recognition systems due to the lack of unsupervised pre-training or self-teaching methods.  It is possible that the results could be further improved by incorporating this.</p>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/paper-notes.bib"></d-bibliography>
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Molin  Zhang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.
Last updated: September 29, 2023.
      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id="></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', '');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
